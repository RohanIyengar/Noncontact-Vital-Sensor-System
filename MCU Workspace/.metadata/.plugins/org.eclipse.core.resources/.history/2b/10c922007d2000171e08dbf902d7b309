

//=========================================================
// src/Interupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES			
#include <SI_EFM8BB1_Register_Enums.h>
#include "retargetserial.h"

//-----------------------------------------------------------------------------
// Global CONSTANTS
//-----------------------------------------------------------------------------
#define UART_BUFFERSIZE        64
#define NOT_SENDING  			8
//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------
uint8_t UART_Buffer[UART_BUFFERSIZE];
uint8_t UART_Buffer_Size = 0;
uint8_t UART_Input_First = 0;
uint8_t UART_Output_First = 0;
uint8_t TX_Ready =1;
uint8_t Byte = 0;

uint32_t mV;// Measured voltage in mV
uint32_t i = 6;
uint8_t byteToBeSent = 0;
bool sendByte = false;
uint32_t numMeasurements = 2048;

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
// This ISR averages 2048 samples then prints the result to the terminal.  The
// ISR is called after each ADC conversion which is triggered by Timer2.
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
{
	static uint32_t accumulator = 0;     // Accumulator for averaging
	static uint16_t measurements = 16; // Measurement counter
	uint32_t result = 0;
	uint32_t high,low,total;
	ADC0CN0_ADINT = 0;// Clear ADC0 conv. complete flag

	//accumulator += ADC0;
	high = ADC0H;
	low = ADC0L;
	total = ADC0;
	accumulator += (high*256) + ADC0L;
	measurements--;

	if(measurements == 0)
	{
		measurements = 16;
		result = accumulator / 16;
		accumulator = 0;

		// The 12-bit ADC value is averaged across 2048 measurements.
		// The measured voltage applied to P0.0 is then:
		//
		//                           Vref (mV)
		//   measurement (mV) =   --------------- * result (bits)
		//                       (2^12)-1 (bits)

		mV = (result * 3300) / 4092;
		//RETARGET_PRINTF ("\nP0.0 voltage: %ld mV\n", mV);
	}

	//Print MSB
	if(measurements == 16)
	{
		i = 3;
		TX_Ready = 1;
	}
	//Print second MSB
	if(measurements == 14)
	{
		i = 2;
		TX_Ready = 1;
	}
	//Print third MSB
	if(measurements == 12)
	{
		i = 1;
		TX_Ready = 1;
	}
	//Print LSB
	if(measurements == 10)
	{
		i = 0;
		TX_Ready = 1;
	}
	//Print comma
	if(measurements == 8)
	{
		i = 4;
		TX_Ready = 1;
	}
	if(measurements < 8)
	{
		i = NOT_SENDING;
		TX_Ready = 0;
	}
}

//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
{

}

//-----------------------------------------------------------------------------
// UART0_ISR
//-----------------------------------------------------------------------------
//
// UART0 ISR Content goes here. Remember to clear flag bits:
// SCON0::RI (Receive Interrupt Flag)
// SCON0::TI (Transmit Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (UART0_ISR, UART0_IRQn)
{
	   if (SCON0_RI == 1)
	   {
		 SCON0_RI = 0;
		 Byte = SBUF0;
	   }

	   if (SCON0_TI == 1)             // Check if transmit flag is set
	   {
	      SCON0_TI = 0;               // Clear interrupt flag
	      switch (i)
	      {
		  	  case 0:
		  		byteToBeSent = 48 + (mV % 10);
		  		sendByte = true;
		  		i = NOT_SENDING;
		  	  	break;
		  	  case 1:
		  		byteToBeSent = 48 + (mV/10)%10;
		  		sendByte = true;
		  		i = NOT_SENDING;
		  		break;
		  	  case 2:
		  		//byteToBeSent = 48 + (mV/100)%10;
		  		  byteToBeSent = '2';
		  		  sendByte = true;
		  		i = NOT_SENDING;
		  		break;
		  	  case 3:
		  		//byteToBeSent = 48 + (mV/1000)%10;
		  		  byteToBeSent = '1';
		  		sendByte = true;
		  		i = NOT_SENDING;
		  		break;
		  	  case 4:
		  		byteToBeSent = ',';
		  		sendByte = true;
		  		i = NOT_SENDING;
		  		break;
		  	  case NOT_SENDING:
		  		sendByte = false;
		  		break;
	      }
	      if(sendByte)
	    	  SBUF0 = byteToBeSent;
	   }

}










/*








//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================


// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>

//-----------------------------------------------------------------------------
// Global CONSTANTS
//-----------------------------------------------------------------------------
#define UART_BUFFERSIZE        64

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------
uint8_t UART_Buffer[UART_BUFFERSIZE];
uint8_t UART_Buffer_Size = 0;
uint8_t UART_Input_First = 0;
uint8_t UART_Output_First = 0;
uint8_t TX_Ready =1;
uint8_t Byte = 0;

//-----------------------------------------------------------------------------
// UART0_ISR
//-----------------------------------------------------------------------------
//
// UART0 ISR Content goes here. Remember to clear flag bits:
// SCON0::RI (Receive Interrupt Flag)
// SCON0::TI (Transmit Interrupt Flag)
//
// This routine is invoked whenever a character is entered or displayed on the
// Hyperterminal.
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (UART0_ISR, UART0_IRQn)
{
	   if (SCON0_RI == 1)
	   {
	      if( UART_Buffer_Size == 0)  {    // If new word is entered
	         UART_Input_First = 0;    }

	      SCON0_RI = 0;                          // Clear interrupt flag

	      Byte = SBUF0;                    // Read a character from UART

	      if (UART_Buffer_Size < UART_BUFFERSIZE)
	      {
	         UART_Buffer[UART_Input_First] = Byte; // Store in array

	         UART_Buffer_Size++;           // Update array's size

	         UART_Input_First++;           // Update counter
	      }
	   }

	   if (SCON0_TI == 1)                        // Check if transmit flag is set
	   {
	      SCON0_TI = 0;                          // Clear interrupt flag

	      if (UART_Buffer_Size != 1)       // If buffer not empty
	      {
	         // If a new word is being output
	         if ( UART_Buffer_Size == UART_Input_First ) {
	              UART_Output_First = 0;  }

	         // Store a character in the variable byte
	         Byte = UART_Buffer[UART_Output_First];

	         if ((Byte >= 0x61) && (Byte <= 0x7A)) { // If upper case letter
	            Byte -= 32; }

	         SBUF0 = Byte;                 // Transmit to Hyperterminal

	         UART_Output_First++;          // Update counter

	         UART_Buffer_Size--;           // Decrease array size

	      }
	      else
	      {
	         UART_Buffer_Size = 0;         // Set the array size to 0
	         TX_Ready = 1;                 // Indicate transmission complete
	      }
	   }
}

SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
{

}

SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
{}
*/
